<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>src - Tag - matteo's blog</title><link>https://matteo-gz.github.io/tags/src/</link><description>src - Tag - matteo's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 20 Sep 2022 10:10:04 +0800</lastBuildDate><atom:link href="https://matteo-gz.github.io/tags/src/" rel="self" type="application/rss+xml"/><item><title>汇编学习</title><link>https://matteo-gz.github.io/posts/asm/</link><pubDate>Tue, 20 Sep 2022 10:10:04 +0800</pubDate><author>Author</author><guid>https://matteo-gz.github.io/posts/asm/</guid><description><![CDATA[什么是汇编? ruanyifeng-汇编语言入门教程 Decode360&rsquo;s Blog-汇编基础入门知识 汇编学习 学习材料: Princeton大学汇编教程 Assembly1 Assembly2 AssemblyFunctions 这个pdf做的非常浅显易懂
tcoline.com-汇编语言 tcoline.com-汇编语言
这个网站的教程也不错,纯中文
w3c教程 https://www.w3cschool.cn/assembly/
函数调用原理 https://gitbook.coder.cat/function-call-principle/
学习记录 目录 编程语言级别:c语言-&gt;汇编语言-&gt;机器语言 x86-64汇编介绍 冯诺伊曼架构介绍 主存 寄存器 汇编函数调用过程 主存 0000000000000000 ... TEXT RODATA DATA BSS HEAP STACK ... FFFFFFFFFFFFFFFF 备注 Data Registers
RAX: register accumulator // R&quot;注册&quot;意思 RBX:register base RCX:register count RDX:register data Data Registers item detail
RAX: register accumulator // R&quot;register&quot; x &ldquo;extended&rdquo; [0,63] EAX: extended accumulator // E &ldquo;extended｜enhanced&rdquo; [0,31] AX: accumulator // [0,15] AH :accumulator higher // [8,15] AL :accumulator lower // [0,7] cont.]]></description></item><item><title>Scalable Go Scheduler Design Doc 中文翻译</title><link>https://matteo-gz.github.io/posts/scalablegoschedulerdesigndoc/</link><pubDate>Thu, 04 Aug 2022 16:36:09 +0800</pubDate><author>Author</author><guid>https://matteo-gz.github.io/posts/scalablegoschedulerdesigndoc/</guid><description>原文链接：https://golang.org/s/go11sched
以下是原文
Scalable Go Scheduler Design Doc Dmitry Vyukov dvyukov@google.com May 2, 2012 该文档假定您对Go 语言 和当前的 goroutine 调度程序实现有一定的了解。
当前调度程序的问题 当前的 goroutine 调度器限制了用 Go 编写的并发程序的可扩展性，特别是高吞吐量服务器和并行计算程序。 Vtocc 服务器在 8 核机器上最多可使用 70% 的 CPU，而性能分析显示 14% 用于runtime.futex(). 通常，调度程序可能会禁止用户在性能至关重要的情况下使用惯用的细粒度并发。
当前实现有什么问题：
单一全局互斥锁（Sched.Lock）和集中状态。互斥锁保护所有与 goroutine 相关的操作（创建、完成、重新调度等）。
Goroutine (G) 切换 (G.nextg)。工作线程 (M&amp;rsquo;s) 经常在彼此之间切换可运行的 goroutine，这可能会导致延迟增加和额外开销。每个 M 必须能够执行任何可运行的 G，尤其是刚刚创建 G 的 M。
每个M内存缓存（M.mcache）。内存缓存和其他缓存（堆栈分配）与所有 M 相关联，而它们只需要与 M 正在运行的 Go 代码相关联（在 syscall 内部阻塞的 M 不需要 mcache）。运行的 Go 代码的M 与所有 M 之间的比率可以高达 1:100。这会导致过多的资源消耗（每个 MCache 最多可吸收 2M）和较差的数据局部性。</description></item></channel></rss>