<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Scalable Go Scheduler Design Doc 中文翻译 - matteo's blog</title><meta name=Description content="This is my cool site"><meta property="og:title" content="Scalable Go Scheduler Design Doc 中文翻译"><meta property="og:description" content="原文链接：https://golang.org/s/go11sched
以下是原文
Scalable Go Scheduler Design Doc Dmitry Vyukov dvyukov@google.com May 2, 2012 该文档假定您对Go 语言 和当前的 goroutine 调度程序实现有一定的了解。
当前调度程序的问题 当前的 goroutine 调度器限制了用 Go 编写的并发程序的可扩展性，特别是高吞吐量服务器和并行计算程序。 Vtocc 服务器在 8 核机器上最多可使用 70% 的 CPU，而性能分析显示 14% 用于runtime.futex(). 通常，调度程序可能会禁止用户在性能至关重要的情况下使用惯用的细粒度并发。
当前实现有什么问题：
单一全局互斥锁（Sched.Lock）和集中状态。互斥锁保护所有与 goroutine 相关的操作（创建、完成、重新调度等）。
Goroutine (G) 切换 (G.nextg)。工作线程 (M&rsquo;s) 经常在彼此之间切换可运行的 goroutine，这可能会导致延迟增加和额外开销。每个 M 必须能够执行任何可运行的 G，尤其是刚刚创建 G 的 M。
每个M内存缓存（M.mcache）。内存缓存和其他缓存（堆栈分配）与所有 M 相关联，而它们只需要与 M 正在运行的 Go 代码相关联（在 syscall 内部阻塞的 M 不需要 mcache）。运行的 Go 代码的M 与所有 M 之间的比率可以高达 1:100。这会导致过多的资源消耗（每个 MCache 最多可吸收 2M）和较差的数据局部性。"><meta property="og:type" content="article"><meta property="og:url" content="https://matteo-gz.github.io/posts/scalablegoschedulerdesigndoc/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-04T16:36:09+08:00"><meta property="article:modified_time" content="2022-08-04T16:36:09+08:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary"><meta name=twitter:title content="Scalable Go Scheduler Design Doc 中文翻译"><meta name=twitter:description content="原文链接：https://golang.org/s/go11sched
以下是原文
Scalable Go Scheduler Design Doc Dmitry Vyukov dvyukov@google.com May 2, 2012 该文档假定您对Go 语言 和当前的 goroutine 调度程序实现有一定的了解。
当前调度程序的问题 当前的 goroutine 调度器限制了用 Go 编写的并发程序的可扩展性，特别是高吞吐量服务器和并行计算程序。 Vtocc 服务器在 8 核机器上最多可使用 70% 的 CPU，而性能分析显示 14% 用于runtime.futex(). 通常，调度程序可能会禁止用户在性能至关重要的情况下使用惯用的细粒度并发。
当前实现有什么问题：
单一全局互斥锁（Sched.Lock）和集中状态。互斥锁保护所有与 goroutine 相关的操作（创建、完成、重新调度等）。
Goroutine (G) 切换 (G.nextg)。工作线程 (M&rsquo;s) 经常在彼此之间切换可运行的 goroutine，这可能会导致延迟增加和额外开销。每个 M 必须能够执行任何可运行的 G，尤其是刚刚创建 G 的 M。
每个M内存缓存（M.mcache）。内存缓存和其他缓存（堆栈分配）与所有 M 相关联，而它们只需要与 M 正在运行的 Go 代码相关联（在 syscall 内部阻塞的 M 不需要 mcache）。运行的 Go 代码的M 与所有 M 之间的比率可以高达 1:100。这会导致过多的资源消耗（每个 MCache 最多可吸收 2M）和较差的数据局部性。"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://matteo-gz.github.io/posts/scalablegoschedulerdesigndoc/><link rel=prev href=https://matteo-gz.github.io/posts/my-gosrc-build-post/><link rel=next href=https://matteo-gz.github.io/posts/gomysql/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Scalable Go Scheduler Design Doc 中文翻译","inLanguage":"en-us","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/matteo-gz.github.io\/posts\/scalablegoschedulerdesigndoc\/"},"genre":"posts","wordcount":393,"url":"https:\/\/matteo-gz.github.io\/posts\/scalablegoschedulerdesigndoc\/","datePublished":"2022-08-04T16:36:09+08:00","dateModified":"2022-08-04T16:36:09+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Author"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="matteo's blog">matteo's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="matteo's blog">matteo's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Scalable Go Scheduler Design Doc 中文翻译</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Author</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-08-04>2022-08-04</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;393 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;2 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#当前调度程序的问题>当前调度程序的问题</a></li><li><a href=#设计>设计</a><ul><li><a href=#processors>Processors</a></li></ul></li><li><a href=#scheduling>Scheduling</a></li><li><a href=#syscallsm-parking-and-unparking>Syscalls/M Parking and Unparking</a></li><li><a href=#terminationdeadlock-detection>Termination/Deadlock Detection</a></li><li><a href=#lockosthread>LockOSThread</a></li><li><a href=#idle-g>Idle G</a></li><li><a href=#实施计划>实施计划</a></li><li><a href=#潜在的进一步改进>潜在的进一步改进</a></li><li><a href=#散记>散记</a></li></ul></nav></div></div><div class=content id=content><p>原文链接：https://golang.org/s/go11sched</p><p>以下是原文</p><hr><h1 id=scalable-go-scheduler-design-doc>Scalable Go Scheduler Design Doc</h1><ul><li>Dmitry Vyukov</li><li><a href=mailto:dvyukov@google.com rel>dvyukov@google.com</a></li><li>May 2, 2012</li></ul><p>该文档假定您对<a href=https://github.com/golang/go target=_blank rel="noopener noreffer">Go 语言</a> 和当前的 goroutine 调度程序实现有一定的了解。</p><h2 id=当前调度程序的问题>当前调度程序的问题</h2><p>当前的 goroutine 调度器限制了用 Go 编写的并发程序的可扩展性，特别是高吞吐量服务器和并行计算程序。
<a href=https://github.com/vitessio/vitess target=_blank rel="noopener noreffer">Vtocc</a> 服务器在 8 核机器上最多可使用 70% 的 CPU，而性能分析显示 14% 用于runtime.futex().
通常，调度程序可能会禁止用户在性能至关重要的情况下使用惯用的细粒度并发。</p><p>当前实现有什么问题：</p><ol><li><p>单一全局互斥锁（Sched.Lock）和集中状态。互斥锁保护所有与 goroutine 相关的操作（创建、完成、重新调度等）。</p></li><li><p>Goroutine (G) 切换 (G.nextg)。工作线程 (M&rsquo;s) 经常在彼此之间切换可运行的 goroutine，这可能会导致延迟增加和额外开销。每个 M 必须能够执行任何可运行的 G，尤其是刚刚创建 G 的 M。</p></li><li><p>每个M内存缓存（M.mcache）。内存缓存和其他缓存（堆栈分配）与所有 M 相关联，而它们只需要与 M 正在运行的 Go 代码相关联（在 syscall 内部阻塞的 M 不需要 mcache）。运行的 Go 代码的M 与所有 M
之间的比率可以高达 1:100。这会导致过多的资源消耗（每个 MCache 最多可吸收 2M）和较差的数据局部性。</p></li><li><p>活跃的线程阻塞中或解除阻塞中。在存在syscalls的情况下，工作线程经常义阻塞和已解除阻塞。这增加了很多开销。</p></li></ol><h2 id=设计>设计</h2><h3 id=processors>Processors</h3><p>总体思路是将 P（Processors）的概念引入运行时，并在Processors之上实现<a href=http://supertech.csail.mit.edu/papers/steal.pdf target=_blank rel="noopener noreffer">work-stealing scheduler</a>。</p><p>M 代表操作系统线程（就像现在一样）。
P 表示执行 Go 代码所需的资源。
当 M 执行 Go 代码时，它有一个关联的 P。
当 M 空闲或在 syscall 中时，它不需要 P。</p><p>正好有 GOMAXPROCS P。所有 P 都组织成一个数组，这是工作窃取的要求。GOMAXPROCS 更改涉及stop/start the world以调整 P 数组的大小。</p><p>sched 中的一些变量被分散并移动到 P。M 中的一些变量被移动到 P（与 Go 代码的主动执行相关的变量）。</p><pre tabindex=0><code>struct P
{
    Lock;
    G *gfree; // freelist, moved from sched
    G *ghead; // runnable, moved from sched
    G *gtail;
    MCache *mcache; // moved from M
    FixAlloc *stackalloc; // moved from M
    uint64 ncgocall;
    GCStats gcstats;
    // etc
    ...
};
P *allp; // [GOMAXPROCS]
还有一个空闲 P 的无锁列表:
P *idlep; // lock-free list
</code></pre><p>当一个 M 愿意开始执行 Go 代码时，它必须从列表中取出一个 P。当 M 结束执行 Go 代码时，它将 P 归还到列表中。因此，当 M 执行 Go 代码时，它必须有一个关联的 P。这种机制取代了 sched.atomic (mcpu/mcpumax)。</p><h2 id=scheduling>Scheduling</h2><p>当一个新的 G 被创建或者一个已经存在的 G 变为可运行时，它会被放进到当前 P 的可运行 goroutines 列表中。当 P 执行完 G 时，它首先尝试从自己的可运行 goroutines 列表中取出一个 G；如果列表为空，则 P
选择一个随机牺牲者（另一个 P）并尝试从中窃取一半可运行的 goroutine。</p><h2 id=syscallsm-parking-and-unparking>Syscalls/M Parking and Unparking</h2><p>当一个 M 创建一个新的 G 时，它必须确保有另一个 M 来执行 G（如果不是所有的 M 都处于忙碌中）。同样，当一个 M 进入 syscall 时，它必须确保有另一个 M 来执行 Go 代码。</p><p>有两种选择，我们可以立即阻塞和非阻塞M，或者使其部分自旋。这是性能和消耗不必要的 CPU 资源之间的内在冲突。这个想法是使用自旋且消耗CPU资源。但是，它不应该影响以 GOMAXPROCS=1 时
的运行程序（command line utilities, appengine,等）。</p><p>自旋分两层：</p><ul><li>(1)一个空闲的 M 关联 P 自旋 ,寻找新的 G，</li><li>(2)一个 M 没关联 P 自旋,等待可用的 P。</li></ul><p>最多有 GOMAXPROCS 个自旋 M((1)和(2))。当有类型 (2) 的空闲 M 时，类型 (1) 的空闲 M 不会阻塞。</p><p>当一个新的 G 被生成，或者 M 进入syscall，或者 M 从空闲到忙碌的转换时，它确保至少有 1 个自旋中 M（或者所有的 P 都忙碌中）。这确保了没有可运行的 G 可以以其他方式运行；同时避免过多的M 进行阻塞或解除阻塞。</p><p>自旋行为主要是被动的（OS驱动, sched_yield()），但可能包括一点主动自旋（循环消耗CPU）（需要调查和调整）。</p><h2 id=terminationdeadlock-detection>Termination/Deadlock Detection</h2><p>Termination/Deadlock Detection(解除/死锁检查)在分布式系统中更成问题。一般的想法是仅在所有 P 都空闲时进行检查（空闲 P 的全局原子计数器），这允许进行涉及每个 P 状态聚合的更昂贵的检查。</p><p>还没有细节。</p><h2 id=lockosthread>LockOSThread</h2><p>此功能不是性能关键的。</p><ol><li><p>锁定的 G 变得不可运行（Gwaiting）。M 立即将 P 返回到空闲列表，唤醒另一个 M 并阻塞。</p></li><li><p>锁定的 G 变为可运行的（并到达 runq 的头部）。当前 M 将自己的 P 和锁定的 G 移交给与锁定的 G 关联的 M，并解锁它。当前 M 变为空闲。</p></li></ol><h2 id=idle-g>Idle G</h2><p>空闲的G;此功能不是性能关键的。</p><p>有一个（或单个?）空闲 G 的全局队列。寻找工作的 M 在几次不成功的窃取尝试后检查队列。</p><h2 id=实施计划>实施计划</h2><p>目标是将整个事情分成可以独立审查和提交的最小部分。</p><ol><li><p>引入 P 结构体（暂时为空）；实现 allp/idlep 容器（idlep 对于初学者来说是互斥保护的）；将 P 与运行 Go 代码的 M 相关联。仍然保留全局互斥锁和原子状态。</p></li><li><p>将 G freelist 移至 P。</p></li><li><p>将mcache移动到P。</p></li><li><p>将stackalloc移动到P。</p></li><li><p>将 ncgocall/gcstats 移至 P。</p></li><li><p>去中心化运行队列，实现工作窃取。消除 G 切换。仍在全局互斥锁下。</p></li><li><p>移除全局互斥体，实现分布式 termination detection，LockOSThread。</p></li><li><p>实施自旋，而不是提示进行阻塞/解除阻塞中.。</p></li></ol><p>该计划可能行不通，有很多未探索的细节。</p><h2 id=潜在的进一步改进>潜在的进一步改进</h2><ol><li><p>尝试LIFO调度，这将提高局部性。但是，它仍然必须提供一定程度的公平性并优雅地处理让出的 goroutine。</p></li><li><p>在goroutine第一次运行之前不要分配G和堆栈。对于一个新创建的 goroutine，我们只需要 callerpc、fn、narg、nret 和 args，也就是大约 6 个单词。这将允许创建大量运行到完成的
goroutine，显着降低内存开销。</p></li><li><p>Without 3</p></li><li><p>更好的G-to-P局部性。尝试将未阻塞的 G 排入上次运行的 P 队列。</p></li><li><p>P-to-M的更好的局部化。尝试在上次运行的同一 M 上执行 P。</p></li><li><p>M创建节约。调度程序很容易被迫每秒创建数千个 M，直到操作系统拒绝创建更多线程。必须及时创建 M 直到 k*GOMAXPROCS，之后可以通过计时器添加新的 M。</p></li></ol><h2 id=散记>散记</h2><ul><li>GOMAXPROCS 不会因为这项工作而消失。</li></ul><hr><p>原文结束</p><p>若翻译细节有错,还望指出</p><p>futex 了解 <a href=https://developer.aliyun.com/article/6043 target=_blank rel="noopener noreffer">https://developer.aliyun.com/article/6043</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-08-04</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://matteo-gz.github.io/posts/scalablegoschedulerdesigndoc/ data-title="Scalable Go Scheduler Design Doc 中文翻译"><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://matteo-gz.github.io/posts/scalablegoschedulerdesigndoc/><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://matteo-gz.github.io/posts/scalablegoschedulerdesigndoc/ data-title="Scalable Go Scheduler Design Doc 中文翻译"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://matteo-gz.github.io/posts/scalablegoschedulerdesigndoc/ data-title="Scalable Go Scheduler Design Doc 中文翻译"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://matteo-gz.github.io/posts/scalablegoschedulerdesigndoc/ data-title="Scalable Go Scheduler Design Doc 中文翻译"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/my-gosrc-build-post/ class=prev rel=prev title=go源码编译><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>go源码编译</a>
<a href=/posts/gomysql/ class=next rel=next title=golang-mysql包>golang-mysql包<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=disqus_thread class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.102.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://https-matteo-gz-github-io.disqus.com/embed.js defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>