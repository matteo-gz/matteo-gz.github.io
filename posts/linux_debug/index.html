<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>linux排查 - matteo's blog</title><meta name=Description content="This is my cool site"><meta property="og:title" content="linux排查"><meta property="og:description" content="Linux性能优化实战 笔记 https://time.geekbang.org/column/intro/100020901
模拟工具 stress stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景
apk add stress-ng
# 一个 CPU 使用率 100% stress --cpu 1 --timeout 600 # 模拟 I/O 压力 stress -i 1 --timeout 600 # 8个进程 stress -c 8 --timeout 600 sysbench sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况
# 以10个线程运行5分钟的基准测试，模拟多线程切换的问题 $ sysbench --threads=10 --max-time=300 threads run ab ab（apache bench）是一个常用的 HTTP 服务性能测试工具
# 并发10个请求测试Nginx性能，总共测试100个请求 $ ab -c 10 -n 100 http://192.168.0.10:10000/ 排查工具 uptime 系统负载 了解系统的负载情况
$ uptime 14:42 up 56 days, 18:09, 2 users, load averages: 1."><meta property="og:type" content="article"><meta property="og:url" content="https://matteo-gz.github.io/posts/linux_debug/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-25T14:45:53+08:00"><meta property="article:modified_time" content="2024-05-25T14:45:53+08:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary"><meta name=twitter:title content="linux排查"><meta name=twitter:description content="Linux性能优化实战 笔记 https://time.geekbang.org/column/intro/100020901
模拟工具 stress stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景
apk add stress-ng
# 一个 CPU 使用率 100% stress --cpu 1 --timeout 600 # 模拟 I/O 压力 stress -i 1 --timeout 600 # 8个进程 stress -c 8 --timeout 600 sysbench sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况
# 以10个线程运行5分钟的基准测试，模拟多线程切换的问题 $ sysbench --threads=10 --max-time=300 threads run ab ab（apache bench）是一个常用的 HTTP 服务性能测试工具
# 并发10个请求测试Nginx性能，总共测试100个请求 $ ab -c 10 -n 100 http://192.168.0.10:10000/ 排查工具 uptime 系统负载 了解系统的负载情况
$ uptime 14:42 up 56 days, 18:09, 2 users, load averages: 1."><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://matteo-gz.github.io/posts/linux_debug/><link rel=prev href=https://matteo-gz.github.io/posts/supervisor/><link rel=next href=https://matteo-gz.github.io/posts/press_linux/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"linux排查","inLanguage":"en-us","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/matteo-gz.github.io\/posts\/linux_debug\/"},"genre":"posts","wordcount":735,"url":"https:\/\/matteo-gz.github.io\/posts\/linux_debug\/","datePublished":"2024-05-25T14:45:53+08:00","dateModified":"2024-05-25T14:45:53+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Author"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="matteo's blog"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/Logo_Matteo-100-360x135px.png data-srcset="/images/Logo_Matteo-100-360x135px.png, /images/Logo_Matteo-100-360x135px.png 1.5x, /images/Logo_Matteo-100-360x135px.png 2x" data-sizes=auto alt=/images/Logo_Matteo-100-360x135px.png title=/images/Logo_Matteo-100-360x135px.png>'s blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><a class=menu-item href=/about/>About </a><a class=menu-item href=/links/>Bookmarks </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="matteo's blog"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/Logo_Matteo-100-360x135px.png data-srcset="/images/Logo_Matteo-100-360x135px.png, /images/Logo_Matteo-100-360x135px.png 1.5x, /images/Logo_Matteo-100-360x135px.png 2x" data-sizes=auto alt=/images/Logo_Matteo-100-360x135px.png title=/images/Logo_Matteo-100-360x135px.png>'s blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=/about/ title>About</a><a class=menu-item href=/links/ title>Bookmarks</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">linux排查</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Author</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2024-05-25>2024-05-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;735 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;4 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#模拟工具>模拟工具</a><ul><li><a href=#stress>stress</a></li><li><a href=#sysbench>sysbench</a></li><li><a href=#ab>ab</a></li></ul></li><li><a href=#排查工具>排查工具</a><ul><li><a href=#uptime-系统负载>uptime 系统负载</a></li><li><a href=#mpstat-cpu>mpstat CPU</a></li><li><a href=#pidstat-进程>pidstat 进程</a></li><li><a href=#vmstat-系统性能>vmstat 系统性能</a></li><li><a href=#top>top</a></li><li><a href=#perf-热点函数>perf 热点函数</a></li><li><a href=#ps-进程>ps 进程</a></li><li><a href=#pstree-进程关系>pstree 进程关系</a></li><li><a href=#strace-跟踪syscall>strace 跟踪syscall</a></li><li><a href=#sar-网络收发>sar 网络收发</a></li><li><a href=#hping3-安全>hping3 安全</a></li><li><a href=#tcpdump-抓包>tcpdump 抓包</a></li><li><a href=#其他工具>其他工具</a></li></ul></li><li><a href=#cpu>CPU</a><ul><li><a href=#上下文切换>上下文切换</a></li><li><a href=#系统的-cpu-使用率很高>系统的 CPU 使用率很高</a></li></ul></li><li><a href=#中断>中断</a><ul><li><a href=#硬中断>硬中断</a></li><li><a href=#软中断>软中断</a></li></ul></li><li><a href=#内存>内存</a><ul><li><a href=#case1--写文件>case1 写文件</a></li><li><a href=#case2-写磁盘>case2 写磁盘</a></li><li><a href=#case3-读取文件>case3 读取文件</a></li><li><a href=#case4-读磁盘>case4 读磁盘</a></li></ul></li><li><a href=#磁盘性能指标>磁盘性能指标</a></li><li><a href=#网络指标>网络指标</a><ul><li><a href=#工具>工具</a></li></ul></li><li><a href=#nat>NAT</a></li><li><a href=#网络优化>网络优化</a><ul><li><a href=#提高网络的吞吐量>提高网络的吞吐量</a></li><li><a href=#请求数比较大>请求数比较大</a></li><li><a href=#缓解-syn-flood>缓解 SYN FLOOD</a></li><li><a href=#长连接>长连接</a></li><li><a href=#upd优化>UPD优化</a></li><li><a href=#路由>路由</a></li><li><a href=#分片>分片</a></li><li><a href=#icmp>ICMP</a></li></ul></li></ul></nav></div></div><div class=content id=content><blockquote><p>Linux性能优化实战 笔记
<a href=https://time.geekbang.org/column/intro/100020901 target=_blank rel="noopener noreffer">https://time.geekbang.org/column/intro/100020901</a></p></blockquote><h2 id=模拟工具>模拟工具</h2><h3 id=stress>stress</h3><blockquote><p>stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景</p></blockquote><p><code>apk add stress-ng</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 一个 CPU 使用率 100%</span>
</span></span><span class=line><span class=cl>stress --cpu <span class=m>1</span> --timeout <span class=m>600</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 模拟 I/O 压力</span>
</span></span><span class=line><span class=cl>stress -i <span class=m>1</span> --timeout <span class=m>600</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 8个进程</span>
</span></span><span class=line><span class=cl> stress -c <span class=m>8</span> --timeout <span class=m>600</span>
</span></span></code></pre></div><h3 id=sysbench>sysbench</h3><blockquote><p>sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 以10个线程运行5分钟的基准测试，模拟多线程切换的问题</span>
</span></span><span class=line><span class=cl>$ sysbench --threads<span class=o>=</span><span class=m>10</span> --max-time<span class=o>=</span><span class=m>300</span> threads run
</span></span></code></pre></div><h3 id=ab>ab</h3><blockquote><p>ab（apache bench）是一个常用的 HTTP 服务性能测试工具</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 并发10个请求测试Nginx性能，总共测试100个请求</span>
</span></span><span class=line><span class=cl>$ ab -c <span class=m>10</span> -n <span class=m>100</span> http://192.168.0.10:10000/
</span></span></code></pre></div><h2 id=排查工具>排查工具</h2><h3 id=uptime-系统负载>uptime 系统负载</h3><blockquote><p>了解系统的负载情况</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ uptime
</span></span><span class=line><span class=cl>14:42  up <span class=m>56</span> days, 18:09, <span class=m>2</span> users, load averages: 1.48 2.10 2.48
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#{{当前时间}} {{系统运行时间}} {{正在登录用户数}} {{过去1分钟的平均负载}}  {{过去5分钟的平均负载}}  {{过去15分钟的平均负载}}</span>
</span></span></code></pre></div><div class=mermaid id=id-1></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 持续观察 -d 参数表示高亮显示变化的区域</span>
</span></span><span class=line><span class=cl>watch -d uptime
</span></span></code></pre></div><h3 id=mpstat-cpu>mpstat CPU</h3><blockquote><p>mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有CPU的平均指标</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据</span>
</span></span><span class=line><span class=cl>mpstat -P ALL <span class=m>5</span>
</span></span></code></pre></div><h3 id=pidstat-进程>pidstat 进程</h3><blockquote><p>pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>apk add sysstat
</span></span><span class=line><span class=cl><span class=c1># 间隔5秒后输出一组数据;-u 代表cpu指标</span>
</span></span><span class=line><span class=cl>pidstat -u <span class=m>5</span> <span class=m>1</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 每隔5秒输出1组数据; -w 查看每个进程上下文切换的情况</span>
</span></span><span class=line><span class=cl>pidstat -w <span class=m>5</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 每隔1秒输出1组数据（需要 Ctrl+C 才结束）</span>
</span></span><span class=line><span class=cl><span class=c1># -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标</span>
</span></span><span class=line><span class=cl>$ pidstat -w -u <span class=m>1</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 每隔1秒输出一组数据（需要 Ctrl+C 才结束）</span>
</span></span><span class=line><span class=cl><span class=c1># -wt 参数表示输出线程的上下文切换指标</span>
</span></span><span class=line><span class=cl>$ pidstat -wt <span class=m>1</span>
</span></span></code></pre></div><h3 id=vmstat-系统性能>vmstat 系统性能</h3><blockquote><p>vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数</p></blockquote><ul><li><p>cs（context switch）是每秒上下文切换的次数。</p></li><li><p>in（interrupt）则是每秒中断的次数。</p></li><li><p>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待CPU的进程数。</p></li><li><p>b（Blocked）则是处于不可中断睡眠状态的进程数。</p></li><li><p>cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数</p></li><li><p>nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数</p></li></ul><p><code>apk add procps</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 每隔5秒输出1组数据</span>
</span></span><span class=line><span class=cl> vmstat <span class=m>5</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 间隔1秒后输出1组数据</span>
</span></span><span class=line><span class=cl>$ vmstat <span class=m>1</span> <span class=m>1</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 每隔1秒输出1组数据（需要Ctrl+C才结束）</span>
</span></span><span class=line><span class=cl>$ vmstat <span class=m>1</span>
</span></span></code></pre></div><h3 id=top>top</h3><ul><li>user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。</li><li>nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。</li><li>system（通常缩写为sys），代表内核态 CPU 时间。</li><li>idle（通常缩写为id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。</li><li>iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。</li><li>irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。</li><li>softirq（通常缩写为 si），代表处理软中断的 CPU 时间。</li><li>steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</li><li>guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</li><li>guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。</li></ul><p>top运行时候按<code>1</code> ,切换到<strong>每个 CPU 的使用率</strong></p><ul><li>VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。</li><li>RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。</li><li>SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。</li><li>%MEM 是进程使用物理内存占系统总内存的百分比。</li></ul><h4 id=s列值意义>S列值意义</h4><ul><li>R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。</li><li>D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。</li><li>Z 是 Zombie 的缩写，它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。</li><li>S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。</li><li>I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl> T 或者 t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态.
</span></span><span class=line><span class=cl>向一个进程发送 SIGSTOP 信号，它就会因响应这个信号变成暂停状态（Stopped）；
</span></span><span class=line><span class=cl>再向它发送 SIGCONT 信号，进程又会恢复运行
</span></span><span class=line><span class=cl>（如果进程是终端里直接启动的，则需要你用 fg 命令，恢复到前台运行）。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>而当你用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，
</span></span><span class=line><span class=cl>这其实也是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的运行。
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl>X，也就是 Dead 的缩写，表示进程已经消亡
</span></span></code></pre></div><div class=mermaid id=id-2></div><h3 id=perf-热点函数>perf 热点函数</h3><blockquote><p>类似于 top，它能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以用来查找热点函数</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>perf top
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># -g开启调用关系分析，-p指定php-fpm的进程号21515</span>
</span></span><span class=line><span class=cl>$ perf top -g -p <span class=m>21515</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 记录性能事件，等待大约15秒后按 Ctrl+C 退出</span>
</span></span><span class=line><span class=cl>$ perf record -g
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看报告</span>
</span></span><span class=line><span class=cl>$ perf report
</span></span></code></pre></div><h3 id=ps-进程>ps 进程</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 从所有进程中查找PID是24344的进程</span>
</span></span><span class=line><span class=cl>$ ps aux <span class=p>|</span> grep <span class=m>24344</span>
</span></span></code></pre></div><h3 id=pstree-进程关系>pstree 进程关系</h3><blockquote><p>用树状形式显示所有进程之间的关系</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ pstree <span class=p>|</span> grep stress
</span></span></code></pre></div><h3 id=strace-跟踪syscall>strace 跟踪syscall</h3><blockquote><p>跟踪进程系统调用的工具</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl> strace -p <span class=m>6082</span>
</span></span></code></pre></div><h3 id=sar-网络收发>sar 网络收发</h3><blockquote><p>是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># -n DEV 表示显示网络收发的报告，间隔1秒输出一组数据</span>
</span></span><span class=line><span class=cl>$ sar -n DEV 
</span></span></code></pre></div><p>item解释</p><ul><li>rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是 PPS</li><li>rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是 BPS</li></ul><h3 id=hping3-安全>hping3 安全</h3><blockquote><p>是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># -S参数表示设置TCP协议的SYN（同步序列号），-p表示目的端口为80</span>
</span></span><span class=line><span class=cl><span class=c1># -i u100表示每隔100微秒发送一个网络帧</span>
</span></span><span class=line><span class=cl><span class=c1># 注：如果你在实践过程中现象不明显，可以尝试把100调小，比如调成10甚至1</span>
</span></span><span class=line><span class=cl>$ hping3 -S -p <span class=m>80</span> -i u100 192.168.0.30
</span></span></code></pre></div><h3 id=tcpdump-抓包>tcpdump 抓包</h3><blockquote><p>是一个常用的网络抓包工具，常用来分析各种网络问题</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># -i eth0 只抓取eth0网卡，-n不解析协议名和主机名</span>
</span></span><span class=line><span class=cl><span class=c1># tcp port 80表示只抓取tcp协议并且端口号为80的网络帧</span>
</span></span><span class=line><span class=cl>$ tcpdump -i eth0 -n tcp port <span class=m>80</span>
</span></span></code></pre></div><h3 id=其他工具>其他工具</h3><ul><li>execsnoop 专为短时进程设计的工具。它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，包括进程 PID、父进程 PID、命令行参数以及执行的结果 <a href=https://github.com/brendangregg/perf-tools/blob/master/execsnoop target=_blank rel="noopener noreffer">https://github.com/brendangregg/perf-tools/blob/master/execsnoop</a></li><li>dstat 吸收了 vmstat、iostat、ifstat 等几种工具的优点</li></ul><h2 id=cpu>CPU</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># cpu个数</span>
</span></span><span class=line><span class=cl>grep <span class=s1>&#39;model name&#39;</span> /proc/cpuinfo <span class=p>|</span> wc -l
</span></span></code></pre></div><h3 id=上下文切换>上下文切换</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># -d 参数表示高亮显示变化的区域</span>
</span></span><span class=line><span class=cl>watch -d cat /proc/interrupts
</span></span></code></pre></div><h3 id=系统的-cpu-使用率很高>系统的 CPU 使用率很高</h3><p>碰到常规问题无法解释的 CPU 使用率情况时，首先要想到有可能是短时应用导致的问题.
pstree会很有用,找到它们的父进程，再从父进程所在的应用入手，排查问题的根源</p><h2 id=中断>中断</h2><p>例子:</p><ul><li>硬中断: 把网卡的数据读到内存中，然后更新一下硬件寄存器的状态;</li><li>软中断: 被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序;</li></ul><h3 id=硬中断>硬中断</h3><blockquote><p>用来快速处理中断;在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>cat /proc/interrupts
</span></span></code></pre></div><h3 id=软中断>软中断</h3><blockquote><p>用来异步处理硬中断未完成的工作,包括网络收发、定时、调度、RCU锁等各种类型;通常以内核线程的方式运行</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>cat /proc/softirqs 
</span></span></code></pre></div><p>存在item</p><ul><li>TIMER（定时中断）</li><li>NET_RX（网络接收）;</li><li>SCHED（内核调度）</li><li>RCU（RCU锁）</li></ul><h2 id=内存>内存</h2><h3 id=case1--写文件>case1 写文件</h3><p>通过读取随机设备，生成一个500MB大小的文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>/dev/urandom <span class=nv>of</span><span class=o>=</span>/tmp/file <span class=nv>bs</span><span class=o>=</span>1M <span class=nv>count</span><span class=o>=</span><span class=m>500</span>
</span></span></code></pre></div><p>Cache在不停地增长，而Buffer基本保持不变;Cache是文件读的缓存;Cache也会缓存写文件时的数据</p><h3 id=case2-写磁盘>case2 写磁盘</h3><p>写磁盘用到了大量的Buffer</p><h3 id=case3-读取文件>case3 读取文件</h3><p>Buffer保持不变，而Cache则在不停增长;Cache是对文件读的页缓存</p><h3 id=case4-读磁盘>case4 读磁盘</h3><p>Buffer和Cache都在增长，但显然Buffer的增长快很多;</p><h2 id=磁盘性能指标>磁盘性能指标</h2><ul><li>使用率，是指磁盘处理I/O的时间百分比。过高的使用率（比如超过80%），通常意味着磁盘 I/O 存在性能瓶颈。</li><li>饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求。</li><li>IOPS（Input/Output Per Second），是指每秒的 I/O 请求数。</li><li>吞吐量，是指每秒的 I/O 请求大小。</li><li>响应时间，是指 I/O 请求从发出到收到响应的间隔时间。</li></ul><h2 id=网络指标>网络指标</h2><ul><li>带宽，表示链路的最大传输速率，单位通常为 b/s （比特/秒）。</li><li>吞吐量，表示单位时间内成功传输的数据量，单位通常为 b/s（比特/秒）或者 B/s（字节/秒）。吞吐量受带宽限制，而吞吐量/带宽，也就是该网络的使用率。</li><li>延时，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同含义。比如，它可以表示，建立连接需要的时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）。</li><li>PPS，是 Packet Per Second（包/秒）的缩写，表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力，比如硬件交换机，通常可以达到线性转发（即 PPS 可以达到或者接近理论最大值）。而基于 Linux 服务器的转发，则容易受网络包大小的影响。</li><li>网络的可用性（网络能否正常通信）</li><li>并发连接数（TCP连接数量）</li><li>丢包率（丢包百分比）</li><li>重传率（重新传输的网络包比例）</li></ul><h3 id=工具>工具</h3><ul><li>ifconfig</li><li>netstat</li><li>ss</li><li>sar</li><li>ping</li></ul><h2 id=nat>NAT</h2><p>分类</p><ul><li>静态 NAT，即内网 IP 与公网 IP 是一对一的永久映射关系；</li><li>动态 NAT，即内网 IP 从公网 IP 池中，动态选择一个进行映射；</li><li>网络地址端口转换 NAPT（Network Address and Port Translation），即把内网 IP 映射到公网 IP 的不同端口上，让多个内网 IP 可以共享同一个公网 IP 地址。</li></ul><h2 id=网络优化>网络优化</h2><h3 id=提高网络的吞吐量>提高网络的吞吐量</h3><ul><li>增大每个套接字的缓冲区大小 <code>net.core.optmem_max</code>；</li><li>增大套接字接收缓冲区大小 <code>net.core.rmem_max</code> 和发送缓冲区大小 <code>net.core.wmem_max</code>；</li><li>增大 TCP 接收缓冲区大小 <code>net.ipv4.tcp_rmem</code> 和发送缓冲区大小 <code>net.ipv4.tcp_wmem</code></li><li>为 TCP 连接设置 <code>TCP_NODELAY</code> 后，就可以禁用 Nagle 算法；</li><li>为 TCP 连接开启 <code>TCP_CORK</code> 后，可以让小包聚合成大包后再发送（注意会阻塞小包的发送）；</li><li>使用 <code>SO_SNDBUF</code> 和 <code>SO_RCVBUF</code> ，可以分别调整套接字发送缓冲区和接收缓冲区的大小。</li></ul><h3 id=请求数比较大>请求数比较大</h3><ul><li>增大处于 TIME_WAIT 状态的连接数量 <code>net.ipv4.tcp_max_tw_buckets</code>,并增大连接跟踪表的大小 <code>net.netfilter.nf_conntrack_max</code></li><li>减小 <code>net.ipv4.tcp_fin_timeout</code> 和 <code>net.netfilter.nf_conntrack_tcp_timeout_time_wait</code> ，让系统尽快释放它们所占用的资源</li><li>开启端口复用 <code>net.ipv4.tcp_tw_reuse</code>。这样，被 TIME_WAIT 状态占用的端口，还能用到新建的连接中。</li><li>增大本地端口的范围 <code>net.ipv4.ip_local_port_range</code> 。这样就可以支持更多连接，提高整体的并发能力</li><li>增加最大文件描述符的数量。你可以使用 <code>fs.nr_open</code> 和 <code>fs.file-max</code> ，分别增大进程和系统的最大文件描述符数；或在应用程序的 systemd 配置文件中，配置 <code>LimitNOFILE</code> ，设置应用程序的最大文件描述符数。</li></ul><h3 id=缓解-syn-flood>缓解 SYN FLOOD</h3><ul><li>增大 TCP 半连接的最大数量 <code>net.ipv4.tcp_max_syn_backlog</code> ，或者开启 TCP SYN Cookies <code>net.ipv4.tcp_syncookies</code> ，来绕开半连接数量限制的问题（注意，这两个选项不可同时使用）</li><li>减少 SYN_RECV 状态的连接重传 SYN+ACK 包的次数 <code>net.ipv4.tcp_synack_retries</code></li></ul><h3 id=长连接>长连接</h3><ul><li>缩短最后一次数据包到 Keepalive 探测包的间隔时间 <code>net.ipv4.tcp_keepalive_time</code></li><li>缩短发送 Keepalive 探测包的间隔时间 <code>net.ipv4.tcp_keepalive_intvl</code>；</li><li>减少Keepalive 探测失败后，一直到通知应用程序前的重试次数 <code>net.ipv4.tcp_keepalive_probes</code></li></ul><h3 id=upd优化>UPD优化</h3><ul><li>增大套接字缓冲区大小以及 UDP 缓冲区范围</li><li>增大本地端口号的范围</li><li>根据 MTU 大小，调整 UDP 数据包的大小，减少或者避免分片的发生</li></ul><h3 id=路由>路由</h3><ul><li>在需要转发的服务器中，比如用作 NAT 网关的服务器或者使用 Docker 容器时，开启 IP 转发，即设置 net.ipv4.ip_forward = 1。</li><li>调整数据包的生存周期 TTL，比如设置 net.ipv4.ip_default_ttl = 64。注意，增大该值会降低系统性能。</li><li>开启数据包的反向地址校验，比如设置 net.ipv4.conf.eth0.rp_filter = 1。这样可以防止 IP 欺骗，并减少伪造 IP 带来的 DDoS 问题。</li></ul><h3 id=分片>分片</h3><ul><li>调整 MTU（Maximum Transmission Unit）的大小</li></ul><h3 id=icmp>ICMP</h3><ul><li>以禁止 ICMP 协议，即设置 <code>net.ipv4.icmp_echo_ignore_all</code> = 1</li><li>禁止广播 ICMP,即设置 <code>net.ipv4.icmp_echo_ignore_broadcasts</code> = 1</li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2024-05-25</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://matteo-gz.github.io/posts/linux_debug/ data-title=linux排查><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://matteo-gz.github.io/posts/linux_debug/><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://matteo-gz.github.io/posts/linux_debug/ data-title=linux排查><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://matteo-gz.github.io/posts/linux_debug/ data-title=linux排查><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://matteo-gz.github.io/posts/linux_debug/ data-title=linux排查><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/supervisor/ class=prev rel=prev title=supervisor搭建><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>supervisor搭建</a>
<a href=/posts/press_linux/ class=next rel=next title=linux压测配置优化>linux压测配置优化<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=disqus_thread class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.117.0">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://https-matteo-gz-github-io.disqus.com/embed.js defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},data:{"id-1":`graph TD
A[CPU 密集型进程] -->|使用大量 CPU | B[平均负载升高]
C[I/O 密集型进程] -->|等待 I/O  | D[平均负载升高,CPU 使用率不一定很高]
E[进程调度] -->|大量等待 CPU 的进程调度 | F[平均负载升高]`,"id-2":`graph TD
A[用户 CPU 和 Nice CPU 高] -->|用户态进程占用了较多的 CPU | B[排查进程的性能]
C[系统 CPU 高] -->|内核态占用了较多的 CPU  | D[排查内核线程or系统调用的性能]
E[I/O 等待 CPU 高] -->|等待 I/O 的时间比较长 | F[排查系统存储是不是出现了 I/O 问题]
H[软中断和硬中断高] --> I[排查内核中的中断服务程序]`},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>